drop policy "Recipients can update friend requests" on "public"."friend_requests";

drop policy "Users can create their own friend requests" on "public"."friend_requests";

drop policy "Users can view their own friend requests" on "public"."friend_requests";

drop policy "Allow users to view tasks of friends" on "public"."tasks";

drop policy "Users can view their own tasks" on "public"."tasks";

drop policy "Users can delete their own dashboard configs" on "public"."dashboard_configs";

drop policy "Users can insert their own dashboard configs" on "public"."dashboard_configs";

drop policy "Users can update their own dashboard configs" on "public"."dashboard_configs";

drop policy "Users can view their own dashboard configs" on "public"."dashboard_configs";

drop policy "Users can delete their own tasks" on "public"."tasks";

drop policy "Users can insert their own tasks" on "public"."tasks";

drop policy "Users can update their own tasks" on "public"."tasks";

create table "public"."notification_delivery_statuses" (
    "id" smallint generated by default as identity not null,
    "status" text not null
);


alter table "public"."notification_delivery_statuses" enable row level security;

create table "public"."notification_types" (
    "id" smallint generated by default as identity not null,
    "type" text not null
);


alter table "public"."notification_types" enable row level security;

CREATE UNIQUE INDEX dashboard_configs_pkey ON public.dashboard_configs USING btree (id);

CREATE INDEX friend_requests_recipient_id_idx ON public.friend_requests USING btree (recipient_id);

CREATE INDEX friend_requests_requester_id_idx ON public.friend_requests USING btree (requester_id);

CREATE UNIQUE INDEX notification_delivery_statuses_pkey ON public.notification_delivery_statuses USING btree (id);

CREATE UNIQUE INDEX notification_types_pkey ON public.notification_types USING btree (id);

CREATE INDEX tasks_user_id_idx ON public.tasks USING btree (user_id);

alter table "public"."dashboard_configs" add constraint "dashboard_configs_pkey" PRIMARY KEY using index "dashboard_configs_pkey";

alter table "public"."notification_delivery_statuses" add constraint "notification_delivery_statuses_pkey" PRIMARY KEY using index "notification_delivery_statuses_pkey";

alter table "public"."notification_types" add constraint "notification_types_pkey" PRIMARY KEY using index "notification_types_pkey";

alter table "public"."notifications" add constraint "notifications_delivery_status_fkey" FOREIGN KEY (delivery_status) REFERENCES notification_delivery_statuses(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."notifications" validate constraint "notifications_delivery_status_fkey";

alter table "public"."notifications" add constraint "notifications_type_fkey" FOREIGN KEY (type) REFERENCES notification_types(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."notifications" validate constraint "notifications_type_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_friends_with_today_task_counts(user_id uuid, updated_at_min timestamp with time zone, tomorrow_str date)
 RETURNS TABLE(id text, user_id uuid, friend_id uuid, friend_username text, status text, created_at timestamp with time zone, today_total_tasks integer, today_completed_tasks integer)
 LANGUAGE sql
AS $function$
SELECT
    fv.id,
    fv.user_id,
    fv.friend_id,
    fv.friend_username,
    fv.status,
    fv.created_at,
    COUNT(t.id) AS today_total_tasks,
    COUNT(t.id) FILTER (WHERE t.is_done) AS today_completed_tasks
FROM friends_view fv
LEFT JOIN tasks t
    ON t.user_id = fv.friend_id
    AND (
        (t.is_done = false AND t.due_date IS NULL)
        OR (t.is_done = false AND t.due_date < tomorrow_str)
        OR (t.is_done = true AND t.updated_at >= updated_at_min)
    )
WHERE fv.user_id = t.user_id
GROUP BY fv.id, fv.user_id, fv.friend_id, fv.friend_username, fv.status, fv.created_at;
$function$
;

grant delete on table "public"."notification_delivery_statuses" to "anon";

grant insert on table "public"."notification_delivery_statuses" to "anon";

grant references on table "public"."notification_delivery_statuses" to "anon";

grant select on table "public"."notification_delivery_statuses" to "anon";

grant trigger on table "public"."notification_delivery_statuses" to "anon";

grant truncate on table "public"."notification_delivery_statuses" to "anon";

grant update on table "public"."notification_delivery_statuses" to "anon";

grant delete on table "public"."notification_delivery_statuses" to "authenticated";

grant insert on table "public"."notification_delivery_statuses" to "authenticated";

grant references on table "public"."notification_delivery_statuses" to "authenticated";

grant select on table "public"."notification_delivery_statuses" to "authenticated";

grant trigger on table "public"."notification_delivery_statuses" to "authenticated";

grant truncate on table "public"."notification_delivery_statuses" to "authenticated";

grant update on table "public"."notification_delivery_statuses" to "authenticated";

grant delete on table "public"."notification_delivery_statuses" to "service_role";

grant insert on table "public"."notification_delivery_statuses" to "service_role";

grant references on table "public"."notification_delivery_statuses" to "service_role";

grant select on table "public"."notification_delivery_statuses" to "service_role";

grant trigger on table "public"."notification_delivery_statuses" to "service_role";

grant truncate on table "public"."notification_delivery_statuses" to "service_role";

grant update on table "public"."notification_delivery_statuses" to "service_role";

grant delete on table "public"."notification_types" to "anon";

grant insert on table "public"."notification_types" to "anon";

grant references on table "public"."notification_types" to "anon";

grant select on table "public"."notification_types" to "anon";

grant trigger on table "public"."notification_types" to "anon";

grant truncate on table "public"."notification_types" to "anon";

grant update on table "public"."notification_types" to "anon";

grant delete on table "public"."notification_types" to "authenticated";

grant insert on table "public"."notification_types" to "authenticated";

grant references on table "public"."notification_types" to "authenticated";

grant select on table "public"."notification_types" to "authenticated";

grant trigger on table "public"."notification_types" to "authenticated";

grant truncate on table "public"."notification_types" to "authenticated";

grant update on table "public"."notification_types" to "authenticated";

grant delete on table "public"."notification_types" to "service_role";

grant insert on table "public"."notification_types" to "service_role";

grant references on table "public"."notification_types" to "service_role";

grant select on table "public"."notification_types" to "service_role";

grant trigger on table "public"."notification_types" to "service_role";

grant truncate on table "public"."notification_types" to "service_role";

grant update on table "public"."notification_types" to "service_role";

create policy "Recipients can accept / reject requests"
on "public"."friend_requests"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = recipient_id));


create policy "Users can send requests"
on "public"."friend_requests"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = requester_id));


create policy "Users can view their own requests"
on "public"."friend_requests"
as permissive
for select
to authenticated
using (((( SELECT auth.uid() AS uid) = requester_id) OR (( SELECT auth.uid() AS uid) = recipient_id)));


create policy "Users can withdraw or reject friend requests"
on "public"."friend_requests"
as permissive
for delete
to authenticated
using (((requester_id = ( SELECT auth.uid() AS uid)) OR (recipient_id = ( SELECT auth.uid() AS uid))));


create policy "Users can view their tasks and their friends tasks"
on "public"."tasks"
as permissive
for select
to authenticated
using (((( SELECT auth.uid() AS uid) = user_id) OR (EXISTS ( SELECT 1
   FROM friend_requests fr
  WHERE ((fr.status = 'confirmed'::text) AND (((fr.requester_id = ( SELECT auth.uid() AS uid)) AND (fr.recipient_id = tasks.user_id)) OR ((fr.recipient_id = ( SELECT auth.uid() AS uid)) AND (fr.requester_id = tasks.user_id))))))));


create policy "Users can delete their own dashboard configs"
on "public"."dashboard_configs"
as permissive
for delete
to public
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Users can insert their own dashboard configs"
on "public"."dashboard_configs"
as permissive
for insert
to public
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Users can update their own dashboard configs"
on "public"."dashboard_configs"
as permissive
for update
to public
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Users can view their own dashboard configs"
on "public"."dashboard_configs"
as permissive
for select
to public
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Users can delete their own tasks"
on "public"."tasks"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Users can insert their own tasks"
on "public"."tasks"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Users can update their own tasks"
on "public"."tasks"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id))
with check ((( SELECT auth.uid() AS uid) = user_id));



